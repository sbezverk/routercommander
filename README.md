# routercommander

## Overview

**routercommander** is the tool developed to automate the collection a large number of commands from a router or a series of routers. As in example of a taking router's health check, the health check might require to run more than 50 commands, doing it one by one is pure insanity, as it will consume significant time; copy and pasting all commands and pray that there is no any syntax error or pasted commands will be correctly accepted by a router is no better option. **routercommander** will execute each command, collect the output and stored it in the file with a router name and the time stamp as a file name. In addition, **routercommander** allows to extend a bit the collection process by introducing several controlling parameters. For example some commands might need to be executed several time and with a specific time interval between them. Some commands might have a required *location* keyword some not. All these particularities can be controlled from the commands YAML file. Please see below a sample of such file for **show cef drop** command.

```yaml
commands:
  - command: show cef drops
    times: 2
    interval: 10
    location:
      - "0/0/CPU0"
      - "0/1/CPU0"
      - "0/2/CPU0"
    patterns:
      - pattern_string: '((:?\w+\s)+)(drops\s+)(packets\s+:)\s+[1-9]\d*\n'
    debug: false
```

As it is clearly seen, this file defines **show cef drops** command.  It also defines a number of times  to execute it **2** as well as a time interval between in seconds **10**. It also instructs **routercommander** to run it only against locations 0/0/CPU0, 0/1/CPU0 and 0/2/CPU0.

the **pattern** keyword defines a pattern to detect an *alarming condition*, it is a part of a health check automation functionality which is still under the development.

## To run

### as a linux binary

**routercommander** leverages the most ubiquitous access method used by network operators, ssh access. The mandatory parameters to run **routercommander** are:

- **--username** defines a user name to use to ssh to a router
- **--password** defines a password to use for ssh authentication
- **--command-file** defines the location of the commands YAML file

**routercommander** can execute the list of commands against a single router, for this case **--router-name** parameter should be used, or in a concurrent manner against a group of routers, the names of routers are stored in a normal text file:

```text
router1
router2
router3
router4
```

and **--routers-file** parameter defines its location.

```bash
routercommander --username=root --password=1234567 --router-name=router1 --command-file=./show_fib.yaml
```

the result of the routercommander execution will be a log file, named with router's name as a prefix and the timestamp of execution as suffix. The log file will container the output generated by the show command.

### as a docker container

Running **routercommander** as a container adds a small twist. Since we are passing 1 external file, the list of commands and expecting the container to create a log file on the external file system, we need to mount or map to the container  these two locations. It will become more clear after reviewing the example. All other parameters are exactly the same.

```bash
docker run --net=host -v /home/some-user/logs:/logs -v /home/nso:/testdata docker.io/sbezverk/routercommander:latest --router-name=router --username=user --password='pass' --v=5 --commands-file=./testdata/show_cef.yaml 
```

First volume we mount or map into the container is for the resulting log file, **-v /home/some-user/logs:/logs** this directive maps physical location **/home/some-user/logs** to the container's internal folder **/logs**,
second volume we map **-v /home/some-user/testdata:/testdata** to give the container access to the commands yaml file.

The resulting log file will be stored in **/home/some-user/logs** folder.
